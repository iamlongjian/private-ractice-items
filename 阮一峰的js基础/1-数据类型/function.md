# 1.函数的属性和方法
### 1.1 name属性
- 返回函数的名称
### 1.2 length属性
- 返回函数形参的个数

# 2.函数特性
### 2.1 函数作用域
- 函数内定义的变量，函数外部无法访问。这就是函数作用域
### 2.2 函数变量提升
- 函数内，也会发生变量提升
```
function demo(){
  console.log(a)
  var a = 1;
}

// 实际上如下
function demo(){
  var a;
  console.log(a) // undefined
  a = 1;
}
```
### 2.3 函数本身的作用域
- 函数在哪里定义的，内部作用域就绑定在哪里
```
var a = 1;
var x = function () {
  console.log(a);
};

function f() {
  var a = 2;
  x();
}

f() // 1  // x函数在全局定义，所以a是全局定义的1
```

# 3.参数传递方式
### 如果参数是普通类型
- 函数参数是普通类型的值，传递方式是（值传递），也就是说在函数内部修改参数值，是不会影响到外部的原值的。
### 如果参数是引用类型
- 函数参数是引用类型的值，传递方式是（引用传递），也就是说在函数内部修改参数值，将会影响到外部的原值。
```
const obj = { a: 1 }
function haha(o) {
  o.a = 2
}
haha(obj)
console.log(obj); // {a:2}
```
### arguments属性
- 该属性是一个**对象**，用于表示实参的集合。默认是可以修改的， 修改后实参的值会发生变化。
> 注意，严格模式下，修改arguments对象，不会影响到实参。

# 4.闭包
首先，需要理解全局作用域与函数作用域。正常情况下，全局作用域无法访问函数作用域内的变量，但是使用闭包可以做到。

用法：函数内部再定义一个函数，该函数返回外层函数的变量。最后在外层函数将内层函数返回，此时就产生了闭包。

```
  function demo() {
    var a = 1
    return function () {
      a++
      console.log(a);
    }
  }
  const d = demo()
  d() // 2
  d() // 3 
  d() // 4
```
> 因此我们可以得知，闭包有两个重要作用
1. 可以在函数外部访问函数内部的变量
2. 可以记忆函数诞生的环境，导致内存记住变量的值

* 但是禁止滥用闭包，因为每调用一次外层函数，就会产生一个闭包。最好把闭包赋值为null，垃圾回收机制才会回收，否则容易造成内存泄漏。